
## პრობლემა: ReverseInt
```
მომხარებელს შემოყავს მთელი რიცხვი n და ჩვენ უნდა დავაბრუნოთ ახალი მთელი რიცხვი output, რომელიც არის შეტრიარებული ვარიანტი n-ისა. მაგალითად 435->534.
```
## ინფორმაციის წაკითხვა:

წავიკითხოთ მომხარებლის მიერ შემოტანილი readInt-ის საშუალებით და შევინახოთ ის. 

```java
int input = readInt("Enter number to reverse: ");
```


## პრობლემის გადაჭრის გზა:

* პირველ რიგში ჩვენ ვალდებულები ვართ წავიკითხოთ მომხარებლის მიერ შემოტანილი რიცხვი და შევინახოთ ის int ცვლადში.

* შემდეგ უმჯობესი იქნება შევქმნათ მეთოდი(reverseInt), რომელსაც გადავცემთ მოხმარებლის მიერ შემოტანილ რიცხვს და რომელიც შეაბრუნებს ამ რიცხს და დაგვიბრუნებს შედეგს, result-ს.

* მთავარი დაბრკოლებაა, როგორ შევაბრუნოთ ეს რიცხვი? პირველ რიგში მეთოდში reverseInt-ში შევქმნათ int result ცვლადი, რომელიც სამომავლოდ იქნება სარკისებული ანარეკლი მოხმარებლის მიერ შემოტანილი input-ისა. ლოგიკური იქნება თუ input-ს წავიკითხავთ ბოლოდან, დავიმახსოვრებთ ბოლო ციფრს და ამ ბოლო ციფრს დავუმატებთ result-ს თავში. შემდეგ ნაბიჯზე ჩვენ უნდა მივადგეთ input-ის ბოლოს წინა ციფრს და ეს ციფრი დავუმატოთ result-ს მეორე პოზიციაზე და ასე გავუვყებით სანამ input-ში ყველა ციფრს არ ამოვწურავთ.

## პრობლემის გადაჭრის კოდად გარდაქმნა:

საინტერესოა როგორ დავიმახსოვრებთ input-ის ბოლო ციფრს და როგორ დავუმატებთ მას result-ს თავში და ა.შ.

ავიღოთ თავიდან result 0-ის ტოლი.

შემდეგ ვაკეთებთ შემდეგ ოპერიაციას: სანამ input იქნება 0 ზე მეტი (სანამ input-ის ყველა ელემენტს არ გადავუყვებით){ 

```java
result = result * 10 + input % 10; (result გავამრავლოთ 10-ზე და დავუმატოთ "ახლანდელი" input-ის ბოლო ციფრი).
```
როდესაც input-ის თავში მოვალთ input უკვე იქნება ერთციფრიანი რიცხვი, რომელიც იქნება 10 ზე ნაკლები, ამ ციფრსაც დავუმატებთ result-ს ბოლოში და ციკლიდანაც გამოვალთ, რადგან "ახლანდელი" input 10 ზე იქნება, 10 ზე გაყოფისას მივიღებთ რიცხვს 0-ს და ციკლიც მორჩება. 
    }
```
    მაგალითად: int inp = 435; int result = 0; 
    		inp = 43; result = 5;
    		inp = 4;  result = 53;
                inp = 0; result = 534;
```
## შესაძლო ხარვეზები:

* ხშირად არის შეცდომები, როდესაც ცვლადს ინიციალიზაციას არ ვუკეთებთ.

*  საინტერესოა ვარიანტია, რა ხდება როდესაც 0 შემოგვდის. იმუშავებს კოდი? ამ დროს ჩვენი კოდის მიხედვით ჩვენ არ შევალთ ლუპში და დავაბრუნებთ პირდაპირ result-ს რომელიც იქნება 0-ის ტოლი.

* ხშირად ამ ამოცანას განიხილავენ მხოლოდ დადებითი მთელი რიცხვებისთვის, რაც საკმაოდ დიდი შეცდომა, რადგან მთელ რიცხვებს მიეკუთვნება ასევე უარყოფითი რიცხვებიც. თუ უარყოფითი რიცხვი შემოგვივა და პრობლემის გადაჭრას ზემოთ ხსენებული კოდით გადავჭრით პასუხად მივიღებთ 0-ს, რაც არასწორია. როდესაც შემოდის -123, ჩვენ ვალდებულები ვართ დავაბრუნოთ -321. თუმცა ამ პრობლემის მოგვარება არც ისე რთულია. როდესაც შემოგვივა რიცხვი, დავიმახსოვროთ უარყოფითია თუ არა boolean ის საშუალებით, გარდავქმნათ ის დადებითად და ზემოხსენებული კოდი გამოვიყენოთ. მივიღებთ დადებით result-ს შემდეგ შევამოწმებთ `boolean negative`-ს, თუ ის true არის მაშინ დავაბრუნოთ -result და პრობლემაც მოგვარდება.


